# -*- coding: utf-8 -*-
from flask import Flask, request
import json
import requests
import os
import time
import re
import threading
from datetime import datetime
import pytz
from dotenv import load_dotenv
import traceback # Hata ayƒ±klama i√ßin eklendi

# .env dosyasƒ±nƒ± y√ºkle
load_dotenv()

app = Flask(__name__)

# .env dosyasƒ±ndan deƒüerleri al
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")
SIGNALS_FILE = os.getenv("SIGNALS_FILE_PATH", "signals.json")
ANALIZ_FILE = os.getenv("ANALIZ_FILE_PATH", "analiz.json")
ANALIZ_SONUCLARI_FILE = os.getenv("ANALIZ_SONUCLARI_FILE_PATH", "analiz_sonuclari.json")

# --- Diƒüer Fonksiyonlar (escape_markdown_v2, send_telegram_message, receive_signal, parse_signal_line, load_json_file, load_analiz_json, load_bist_analiz_json, generate_analiz_response, telegram_webhook, generate_summary, clear_signals_endpoint, clear_signals, clear_signals_daily) ---
# BU KISIMLAR √ñNCEKƒ∞ KOD ƒ∞LE AYNI, BURAYA TEKRAR KOPYALANMADI.
# Sadece generate_bist_analiz_response fonksiyonunu deƒüi≈ütiriyoruz.

def escape_markdown_v2(text):
    """
    Telegram MarkdownV2 i√ßin √∂zel karakterleri ka√ßƒ±rƒ±r.
    """
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    return re.sub(f'([{re.escape(escape_chars)}])', r'\\\1', text)

def send_telegram_message(message):
    """Telegram'a mesaj g√∂nderir, MarkdownV2 ka√ßƒ±rma i≈ülemi yapar ve uzun mesajlarƒ± b√∂ler."""
    escaped_message = escape_markdown_v2(message)
    max_length = 4096
    for i in range(0, len(escaped_message), max_length):
        chunk = escaped_message[i:i+max_length]
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = {
            "chat_id": CHAT_ID,
            "text": chunk,
            "parse_mode": "MarkdownV2"
        }
        try:
            r = requests.post(url, json=data, timeout=20)
            r.raise_for_status()
            print(f"‚úÖ Telegram yanƒ±tƒ±: {r.status_code}")
        except requests.exceptions.Timeout:
            print(f"‚ùå Telegram API zaman a≈üƒ±mƒ±na uƒüradƒ±.")
        except requests.exceptions.HTTPError as http_err:
            print(f"‚ùå Telegram HTTP Hatasƒ±: {http_err} - Yanƒ±t: {r.text}")
            print(f"‚ùå G√∂nderilemeyen mesaj (orijinal): {message[i:i+max_length]}")
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Telegram'a mesaj g√∂nderilemedi (RequestException): {e}")
            print(f"‚ùå G√∂nderilemeyen mesaj (orijinal): {message[i:i+max_length]}")
        except Exception as e:
            print(f"‚ùå Beklenmedik hata (Telegram g√∂nderimi): {e}")
            print(f"‚ùå G√∂nderilemeyen mesaj (orijinal): {message[i:i+max_length]}")

# Diƒüer endpointler ve fonksiyonlar buradaydƒ±...

def load_json_file(filepath):
    """Genel JSON dosyasƒ± y√ºkleme fonksiyonu."""
    try:
        if not os.path.exists(filepath):
             print(f"Uyarƒ±: {filepath} dosyasƒ± bulunamadƒ±.")
             return None
        if os.path.getsize(filepath) == 0:
            print(f"Uyarƒ±: {filepath} dosyasƒ± bo≈ü.")
            return {}
        with open(filepath, "r", encoding="utf-8") as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"Uyarƒ±: {filepath} dosyasƒ± bulunamadƒ±.")
        return {}
    except json.JSONDecodeError as e:
        print(f"‚ùå Hata: {filepath} dosyasƒ± ge√ßerli bir JSON formatƒ±nda deƒüil. Hata: {e}")
        try:
             with open(filepath, "r", encoding="utf-8") as f_err:
                 print(f"Dosyanƒ±n ba≈üƒ±: {f_err.read(100)}...")
        except Exception:
             pass
        return {}
    except IOError as e:
        print(f"‚ùå G/√á Hatasƒ± ({filepath} okuma): {e}")
        return {}
    except Exception as e:
        print(f"‚ùå Beklenmedik Hata ({filepath} okuma): {e}")
        return {}

def load_bist_analiz_json():
    data = load_json_file(ANALIZ_SONUCLARI_FILE)
    return data if data is not None else {}

# --- /bist_analiz i√ßin G√ºncellenmi≈ü Fonksiyon ---
def generate_bist_analiz_response(tickers):
    """
    Verilen hisse listesi i√ßin analiz_sonuclari.json'dan veri √ßeker.
    '√ñne √áƒ±kanlar' listesindeki her madde i√ßin i√ßeriƒüe g√∂re farklƒ± emoji kullanƒ±r.
    """
    all_analiz_data = load_bist_analiz_json()
    response_lines = []

    if not all_analiz_data:
         return f"‚ö†Ô∏è Detaylƒ± analiz verileri (`{os.path.basename(ANALIZ_SONUCLARI_FILE)}`) y√ºklenemedi veya bo≈ü."

    # Anahtar kelimelere g√∂re emoji e≈üle≈ütirme (daha spesifik olanlar √∂nce gelmeli)
    # Bu listeyi kendi metriklerinize ve istediƒüiniz emojilere g√∂re d√ºzenleyebilirsiniz.
    emoji_map = {
        "peg oranƒ±": "üéØ",
        "f/k oranƒ±": "üí∞",
        "net bor√ß/fav√∂k": "üè¶",
        "net d√∂nem karƒ±": "üìà", # Artƒ±≈ü/Azalƒ±≈üa g√∂re emoji deƒüi≈üebilir (daha karma≈üƒ±k)
        "finansal bor√ß": "üìâ",  # Genellikle azalƒ±≈üƒ± istenir
        "net bor√ß": "üí∏",      # Artƒ±≈ü/Azalƒ±≈üa g√∂re emoji deƒüi≈üebilir
        "d√∂nen varlƒ±klar": "üîÑ",
        "duran varlƒ±klar": "üè¢",
        "toplam varlƒ±klar": "üèõÔ∏è",
        "√∂zkaynak": "üß±",
        # Eklenebilecek diƒüer metrikler...
        "default": "‚û°Ô∏è" # E≈üle≈üme bulunamazsa kullanƒ±lacak varsayƒ±lan emoji
    }

    for ticker in tickers:
        analiz_data = all_analiz_data.get(ticker.strip().upper())

        if analiz_data:
            symbol = analiz_data.get("symbol", ticker.strip().upper())
            score = analiz_data.get("score", "N/A")
            classification = analiz_data.get("classification", "Belirtilmemi≈ü")
            comments = analiz_data.get("comments", [])

            formatted_comments_list = []
            if comments and isinstance(comments, list):
                for comment in comments:
                    comment_lower = comment.lower() # K√º√ß√ºk harfe √ßevirerek kontrol
                    chosen_emoji = emoji_map["default"] # Varsayƒ±lan emoji ile ba≈üla

                    # E≈üle≈üme bulmak i√ßin anahtar kelimeleri kontrol et
                    # Not: Bu basit bir kontrol. Daha karma≈üƒ±k metinler i√ßin regex gerekebilir.
                    # √ñnem sƒ±rasƒ±na g√∂re veya en spesifik e≈üle≈ümeyi bulacak ≈üekilde kontrol edilebilir.
                    found_match = False
                    for keyword, emoji in emoji_map.items():
                        if keyword == "default": continue # Default anahtar kelimesini atla

                        # Anahtar kelimenin yorum i√ßinde ge√ßip ge√ßmediƒüini kontrol et
                        # Daha saƒülam olmasƒ± i√ßin kelime sƒ±nƒ±rlarƒ± (\b) ile regex kullanƒ±labilir:
                        # if re.search(r'\b' + re.escape(keyword) + r'\b', comment_lower):
                        # ≈ûimdilik basit 'in' kontrol√º yapalƒ±m:
                        if keyword in comment_lower:
                            chosen_emoji = emoji
                            found_match = True
                            break # ƒ∞lk e≈üle≈ümeyi bulduƒüumuzda d√∂ng√ºden √ßƒ±k (veya en iyi e≈üle≈ümeyi ara)

                    formatted_comments_list.append(f"{chosen_emoji} {comment}") # Se√ßilen emoji + orijinal yorum

                formatted_comments = "\n".join(formatted_comments_list)
            else:
                formatted_comments = "Yorum bulunamadƒ±."

            # Mesajƒ± olu≈ütur
            response_lines.append(
                f"üìä Bƒ∞ST Detaylƒ± Analiz\n\n"
                f"üè∑Ô∏è Sembol: {symbol}\n"
                f"üìà Puan: {score}\n"
                f"üèÖ Sƒ±nƒ±flandƒ±rma: {classification}\n\n"
                f"üìù √ñne √áƒ±kanlar:\n{formatted_comments}" # Dinamik emojili yorumlar
            )
        else:
            response_lines.append(f"‚ùå {ticker.strip().upper()} i√ßin detaylƒ± analiz bulunamadƒ±.")

    return "\n\n".join(response_lines)

# --- Telegram Webhook (Deƒüi≈üiklik Yok) ---
@app.route("/telegram", methods=["POST"])
def telegram_webhook():
    print(">>> /telegram endpoint tetiklendi")
    try:
        update = request.json
        if not update:
            print("Bo≈ü JSON verisi alƒ±ndƒ±.")
            return "ok", 200

        message = update.get("message") or update.get("edited_message")
        if not message:
            # Desteklenmeyen g√ºncellemeleri logla ve atla
            update_type = next((key for key in update if key != 'update_id'), 'bilinmiyor')
            print(f"Desteklenmeyen g√ºncelleme t√ºr√º '{update_type}' alƒ±ndƒ±, i≈ülenmiyor.")
            return "ok", 200

        text = message.get("text", "").strip()
        chat_info = message.get("chat")
        user_info = message.get("from")

        if not chat_info or not user_info:
             print("‚ùå Sohbet veya kullanƒ±cƒ± bilgisi eksik, mesaj i≈ülenemiyor.")
             return "ok", 200

        chat_id = chat_info.get("id")
        user_id = user_info.get("id")
        first_name = user_info.get("first_name", "")
        username = user_info.get("username", "N/A")

        if str(chat_id) != CHAT_ID:
            print(f"‚ö†Ô∏è Uyarƒ±: Mesaj beklenen sohbetten ({CHAT_ID}) gelmedi. Gelen: {chat_id}. ƒ∞≈ülenmeyecek.")
            return "ok", 200

        if not text:
            print("Bo≈ü mesaj i√ßeriƒüi alƒ±ndƒ±.")
            return "ok", 200

        print(f">>> Mesaj alƒ±ndƒ± (Chat: {chat_id}, User: {first_name} [{username}/{user_id}]): {text}")

        response_message = ""
        # Komut i≈üleme mantƒ±ƒüƒ± (√ñnceki kod ile aynƒ±)
        if text.startswith("/ozet"):
            print(">>> /ozet komutu i≈üleniyor...")
            parts = text.split(maxsplit=1)
            keyword = parts[1].lower() if len(parts) > 1 else None
            allowed_keywords = ["bats", "nasdaq", "bist_dly", "binance", "bist"]
            print(f"Anahtar kelime: {keyword}")
            if keyword and keyword not in allowed_keywords:
                 allowed_str = ", ".join([f"`{k}`" for k in allowed_keywords])
                 response_message = f"‚ö†Ô∏è Ge√ßersiz anahtar kelime: `{keyword}`. ƒ∞zin verilenler: {allowed_str}"
                 print(f"Ge√ßersiz √∂zet anahtar kelimesi: {keyword}")
            else:
                 # generate_summary fonksiyonu √ßaƒürƒ±lƒ±r (√∂nceki kodda tanƒ±mlƒ±)
                 summary = generate_summary(keyword) # Bu fonksiyonun var olduƒüunu varsayƒ±yoruz
                 response_message = summary
        elif text.startswith("/analiz"):
            print(">>> /analiz komutu i≈üleniyor...")
            tickers_input = text[len("/analiz"):].strip()
            if not tickers_input:
                 response_message = "L√ºtfen bir veya daha fazla hisse kodu belirtin. √ñrnek: `/analiz AAPL, MSFT, AMD`"
            else:
                tickers = [ticker.strip().upper() for ticker in re.split(r'[,\s]+', tickers_input) if ticker.strip()]
                if not tickers:
                     response_message = "Ge√ßerli bir hisse kodu bulunamadƒ±. √ñrnek: `/analiz AAPL, MSFT`"
                else:
                    print(f"Analiz istenen hisseler (/analiz): {tickers}")
                    # generate_analiz_response fonksiyonu √ßaƒürƒ±lƒ±r (√∂nceki kodda tanƒ±mlƒ±)
                    response_message = generate_analiz_response(tickers) # Bu fonksiyonun var olduƒüunu varsayƒ±yoruz
        elif text.startswith("/bist_analiz"): # G√úNCELLENMƒ∞≈û FONKSƒ∞YONU KULLANIR
            print(">>> /bist_analiz komutu i≈üleniyor...")
            tickers_input = text[len("/bist_analiz"):].strip()
            if not tickers_input:
                response_message = "L√ºtfen bir veya daha fazla BIST hisse kodu belirtin. √ñrnek: `/bist_analiz MIATK, THYAO`"
            else:
                tickers = [ticker.strip().upper() for ticker in re.split(r'[,\s]+', tickers_input) if ticker.strip()]
                if not tickers:
                     response_message = "Ge√ßerli bir hisse kodu bulunamadƒ±. √ñrnek: `/bist_analiz MIATK, THYAO`"
                else:
                    print(f"Detaylƒ± analiz istenen hisseler (/bist_analiz): {tickers}")
                    response_message = generate_bist_analiz_response(tickers) # YENƒ∞ G√úNCELLENMƒ∞≈û FONKSƒ∞YON
        elif text.startswith("/start") or text.startswith("/help"):
             print(">>> /start veya /help komutu i≈üleniyor...")
             response_message = "üëã Merhaba! Kullanabileceƒüiniz komutlar:\n\n" \
                                "‚Ä¢ `/ozet` : T√ºm borsalardan gelen sinyallerin √∂zetini g√∂sterir.\n" \
                                "‚Ä¢ `/ozet [borsa]` : Belirli bir borsa i√ßin √∂zet g√∂sterir (√ñrn: `/ozet bist`, `/ozet nasdaq`).\n" \
                                "‚Ä¢ `/analiz [Hƒ∞SSE1,Hƒ∞SSE2,...]` : Belirtilen hisseler i√ßin temel analiz puanƒ±nƒ± ve yorumunu g√∂sterir (√ñrn: `/analiz GOOGL,AAPL`).\n" \
                                "‚Ä¢ `/bist_analiz [Hƒ∞SSE1,Hƒ∞SSE2,...]` : Belirtilen BIST hisseleri i√ßin daha detaylƒ± analizi g√∂sterir (√ñrn: `/bist_analiz EREGL, TUPRS`).\n" \
                                "‚Ä¢ `/help` : Bu yardƒ±m mesajƒ±nƒ± g√∂sterir."
        else:
            print(f"Bilinmeyen komut veya metin alƒ±ndƒ±: {text}")
            # response_message = f"‚ùì `{text}` komutunu anlayamadƒ±m. Yardƒ±m i√ßin `/help` yazabilirsiniz."

        if response_message:
             send_telegram_message(response_message)
        else:
             print("ƒ∞≈ülenecek bilinen bir komut bulunamadƒ±, yanƒ±t g√∂nderilmedi.")

        return "ok", 200

    except Exception as e:
        print(f"‚ùå /telegram endpoint genel hatasƒ±: {e}")
        print(traceback.format_exc())
        try:
             error_message = f"ü§ñ √úzg√ºn√ºm, isteƒüinizi i≈ülerken bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin."
             if 'chat_id' in locals() and str(chat_id) == CHAT_ID:
                 send_telegram_message(error_message)
             else:
                 print("Hata olu≈ütu ancak hedef sohbet ID'si belirlenemedi veya yetkisiz.")
        except Exception as telegram_err:
             print(f"‚ùå Hata mesajƒ± Telegram'a g√∂nderilemedi: {telegram_err}")
        return "Internal Server Error", 500


# --- Uygulama Ba≈ülangƒ±cƒ± ve Diƒüer Fonksiyonlar ---
# generate_summary, clear_signals_endpoint, clear_signals, clear_signals_daily, __main__ bloƒüu
# √∂nceki kod ile aynƒ± kabul edildi ve buraya eklenmedi.
# KODUN TAMAMINI √áALI≈ûTIRMAK ƒ∞√áƒ∞N BU KISIMLARI √ñNCEKƒ∞ VERSƒ∞YONDAN ALIP
# generate_bist_analiz_response fonksiyonunu bu dosyadaki ile deƒüi≈ütirin.

if __name__ == "__main__":
    print("üöÄ Flask uygulamasƒ± ba≈ülatƒ±lƒ±yor...")
    # Eksik fonksiyonlarƒ± varsayƒ±lan olarak ekleyelim (ger√ßek kodda bunlar olmalƒ±)
    def generate_summary(keyword=None): return "√ñzet olu≈üturuluyor..."
    def generate_analiz_response(tickers): return "Analiz olu≈üturuluyor..."
    def clear_signals(): print("Sinyaller temizleniyor..."); return True
    def clear_signals_daily(): print("G√ºnl√ºk temizlik d√∂ng√ºs√º √ßalƒ±≈üƒ±yor..."); time.sleep(3600) # Sadece g√∂stermelik
    @app.route("/signal", methods=["POST"])
    def receive_signal(): return "ok", 200
    @app.route("/clear_signals", methods=["POST"])
    def clear_signals_endpoint(): clear_signals(); return "ok", 200

    # Arka plan temizlik g√∂revini ba≈ülat (ger√ßek kodda bu olmalƒ±)
    # cleanup_thread = threading.Thread(target=clear_signals_daily, daemon=True)
    # cleanup_thread.start()
    # print("‚úÖ G√ºnl√ºk sinyal temizleme g√∂revi arka planda ba≈ülatƒ±ldƒ±.")

    port = int(os.getenv("PORT", 5000))
    debug_mode = os.getenv("FLASK_DEBUG", "False").lower() == "true"
    print(f"üîß Ayarlar: Port={port}, Debug={debug_mode}")
    print(f"üîß Telegram Bot Token: {'Var' if BOT_TOKEN else 'Yok!'}, Chat ID: {'Var' if CHAT_ID else 'Yok!'}")
    if not BOT_TOKEN or not CHAT_ID: print("‚ùå UYARI: BOT_TOKEN veya CHAT_ID .env dosyasƒ±nda ayarlanmamƒ±≈ü!")

    app.run(host="0.0.0.0", port=port, debug=debug_mode)
