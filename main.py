# -*- coding: utf-8 -*-
from flask import Flask, request
import json
import requests
import os
import time
import re
import threading
from datetime import datetime
import pytz
from dotenv import load_dotenv

# .env dosyasƒ±nƒ± y√ºkle
load_dotenv()

app = Flask(__name__)

# .env dosyasƒ±ndan deƒüerleri al
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")
# DOSYA YOLLARI
SIGNALS_FILE = os.getenv("SIGNALS_FILE_PATH", "signals.json")
ANALIZ_FILE = os.getenv("ANALIZ_FILE_PATH", "analiz.json")
ANALIZ_SONUCLARI_FILE = os.getenv("ANALIZ_SONUCLARI_FILE_PATH", "analiz_sonuclari.json")

# --- Helper Functions ---

def escape_markdown_v2(text):
    """
    Telegram MarkdownV2 i√ßin *yalnƒ±zca* potansiyel olarak sorunlu metin par√ßalarƒ±nƒ±
    (√∂rn. hisse senedi sembolleri, borsa adlarƒ±, serbest metin sinyalleri, hata mesajlarƒ±)
    g√ºvenli hale getirmek i√ßin kullanƒ±lƒ±r. T√úM √∂zel karakterleri ka√ßƒ±rƒ±r.
    """
    # Telegram'ƒ±n rezerv ettiƒüi T√úM karakterleri ka√ßƒ±rƒ±r: _ * [ ] ( ) ~ ` > # + - = | { } . !
    escape_chars = r"\_*[]()~`>#+-=|{}.!"
    return re.sub(r"([{}])".format(re.escape(escape_chars)), r"\\\1", str(text))

# *** √ñNEMLƒ∞: Bu fonksiyon ARTIK ESCAPE YAPMIYOR ***
def send_telegram_message(message_text):
    """
    Mesajƒ± Telegram'a g√∂nderir, MarkdownV2 kullanƒ±r.
    Mesajƒ±n ZATEN doƒüru formatta ve escape edilmi≈ü olmasƒ± gerekir.
    """
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    # Mesajƒ± 4096 karakterlik par√ßalara b√∂l
    for i in range(0, len(message_text), 4096):
        chunk = message_text[i:i+4096]
        data = {
            "chat_id": CHAT_ID,
            "text": chunk,
            "parse_mode": "MarkdownV2"
        }
        try:
            r = requests.post(url, json=data, timeout=20)
            r.raise_for_status()
            response_json = r.json()
            if response_json.get("ok"):
                print(f"‚úÖ Mesaj par√ßasƒ± ba≈üarƒ±yla g√∂nderildi (Chat ID: {CHAT_ID})")
            else:
                print(f"‚ùå Telegram API hatasƒ±: {response_json.get('description')}")
                print(f"‚ùå Hatalƒ± Chunk (g√∂nderilen): {chunk[:200]}...") # G√∂nderilmeye √ßalƒ±≈üƒ±lan chunk'ƒ± logla
        except requests.exceptions.Timeout:
            print(f"‚ùå Telegram API isteƒüi zaman a≈üƒ±mƒ±na uƒüradƒ± (URL: {url})")
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Telegram'a mesaj g√∂nderilemedi: {e}")
            print(f"‚ùå G√∂nderilemeyen mesaj par√ßasƒ± (orijinal): {chunk[:200]}...")
        except json.JSONDecodeError:
             print(f"‚ùå Telegram API'den ge√ßerli JSON yanƒ±tƒ± alƒ±namadƒ±. Yanƒ±t: {r.text}")
        except Exception as e:
            print(f"‚ùå Beklenmedik hata (Telegram g√∂nderimi): {e}")
            print(f"‚ùå Hata detayƒ± (Tip): {type(e)}")


def parse_signal_line(line):
    try: return json.loads(line)
    except json.JSONDecodeError: print(f"‚ö†Ô∏è JSON parse hatasƒ± (atlandƒ±): {line.strip()}"); return None

def load_json_file(filepath):
    try:
        with open(filepath, "r", encoding="utf-8") as file: return json.load(file)
    except FileNotFoundError: print(f"Uyarƒ±: '{filepath}' dosyasƒ± bulunamadƒ±."); return {}
    except json.JSONDecodeError: print(f"Hata: '{filepath}' dosyasƒ± ge√ßerli bir JSON formatƒ±nda deƒüil."); return {}
    except Exception as e: print(f"Beklenmedik Hata ('{filepath}' okuma): {e}"); return {}

# --- Flask Routes ---

@app.route("/signal", methods=["POST"])
def receive_signal():
    print(f"[{datetime.now()}] >>> /signal endpoint tetiklendi")
    try:
        # ... (Veri alma kƒ±smƒ± aynƒ±) ...
        if request.is_json: data = request.get_json()
        elif request.content_type == 'text/plain':
            raw_text = request.data.decode("utf-8").strip()
            parts = raw_text.split(None, 2); symbol = "Bilinmiyor"; exchange = "Bilinmiyor"; signal_msg = raw_text
            match_exchange = re.match(r"^(.*?)\s+\((.*?)\)\s*-\s*(.*)$", raw_text)
            if match_exchange: symbol, exchange, signal_msg = match_exchange.groups()
            elif len(parts) >= 2: symbol = parts[0]; signal_msg = " ".join(parts[1:])
            elif len(parts) == 1: signal_msg = parts[0]
            data = {"symbol": symbol.strip(), "exchange": exchange.strip(), "signal": signal_msg.strip()}
        else: return "Unsupported Media Type", 415
        # ... (Timestamp ekleme aynƒ±) ...
        data["timestamp_utc"] = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        try: tz_istanbul = pytz.timezone("Europe/Istanbul"); data["timestamp_tr"] = datetime.now(tz_istanbul).strftime("%Y-%m-%d %H:%M:%S")
        except Exception as tz_err: print(f"Yerel zaman alƒ±nƒ±rken hata: {tz_err}"); data["timestamp_tr"] = "Hata"
        # ... (Dosyaya yazma aynƒ±) ...
        try:
            with open(SIGNALS_FILE, "a", encoding="utf-8") as f: f.write(json.dumps(data, ensure_ascii=False) + "\n")
        except IOError as e:
             print(f"‚ùå Sinyal dosyasƒ±na yazƒ±lamadƒ± ({SIGNALS_FILE}): {e}")
             # Hata mesajƒ±nƒ± escape et ve g√∂nder
             send_telegram_message(f"‚ö†Ô∏è *UYARI:* Sinyal dosyasƒ±na yazƒ±lamadƒ±\\! Hata: `{escape_markdown_v2(str(e))}`")

        # --- Mesaj Olu≈üturma (D√ºzeltilmi≈ü Escaping) ---
        # Sadece deƒüi≈üken i√ßerikleri escape et
        symbol_esc = escape_markdown_v2(data.get("symbol", "Bilinmiyor"))
        exchange_raw = data.get("exchange", "Bilinmiyor")
        signal_msg_esc = escape_markdown_v2(data.get("signal", "ƒ∞√ßerik Yok"))
        timestamp_tr_raw = data.get("timestamp_tr", "N/A") # Zamanƒ± escape etmeye gerek yok (genelde)
        # Zaman i√ßindeki '-' veya '.' sorun √ßƒ±karƒ±rsa escape edilebilir:
        # timestamp_tr_esc = escape_markdown_v2(timestamp_tr_raw)

        # Borsa adƒ±nƒ± g√ºzelle≈ütir ve sadece sonucu escape et
        exchange_display = exchange_raw.replace("BIST_DLY", "BIST").replace("BATS", "NASDAQ")
        exchange_display_escaped = escape_markdown_v2(exchange_display)

        # Mesajƒ± olu≈ütururken literal karakterleri manuel escape et (\)
        # √ñrneƒüin parantezleri: \( ve \)
        message = f"üì° *Yeni Sinyal Geldi*\n\n" \
                  f"ü™ô *Sembol:* `{symbol_esc}`\n" \
                  f"üè¶ *Borsa:* {exchange_display_escaped}\n" \
                  f"üí¨ *Sinyal:* _{signal_msg_esc}_\n" \
                  f"‚è∞ *Zaman \\(TR\\):* {timestamp_tr_raw}" # TR zamanƒ± i√ßin parantezler manuel escape edildi

        send_telegram_message(message)
        return "ok", 200
    # ... (Hata yakalama aynƒ±, i√ßindeki escape'ler doƒüru) ...
    except json.JSONDecodeError as e: print(f"‚ùå /signal JSON parse hatasƒ±: {e}"); print(f"Gelen Ham Veri: {request.data}"); return f"Bad Request: Invalid JSON - {e}", 400
    except Exception as e:
        print(f"‚ùå /signal endpoint genel hatasƒ±: {e}"); print(f"‚ùå Hata Tipi: {type(e)}")
        try: error_message = f"‚ùå `/signal` endpointinde kritik hata olu≈ütu\\!\n*Hata:* `{escape_markdown_v2(str(e))}`"; send_telegram_message(error_message)
        except Exception as telegram_err: print(f"‚ùå Hata mesajƒ± Telegram'a g√∂nderilemedi: {telegram_err}")
        return f"Internal Server Error: {e}", 500


@app.route("/telegram", methods=["POST"])
def telegram_webhook():
    # ... (Webhook ba≈ülangƒ±cƒ± ve kontroller aynƒ±) ...
    print(f"[{datetime.now()}] >>> /telegram endpoint tetiklendi")
    update = request.json; #...
    message = update.get("message") or update.get("channel_post"); #...
    text = message.get("text", "").strip(); chat_id = message.get("chat", {}).get("id"); #...
    if str(chat_id) != CHAT_ID: return "ok", 200
    if not text: return "ok", 200
    # ... (Loglama aynƒ±) ...
    print(f">>> Mesaj alƒ±ndƒ± ... '{text}'")

    response_message = None
    try:
        if text.startswith("/ozet"):
            print(">>> /ozet komutu i≈üleniyor...")
            keyword = text[6:].strip().lower() if len(text) > 6 else None
            allowed_keywords = ["bats", "nasdaq", "bist_dly", "binance", "bist"]
            if keyword and keyword not in allowed_keywords:
                 allowed_str = ", ".join([f"`{k}`" for k in allowed_keywords])
                 # keyword'√º escape et, literal '.' manuel escape
                 response_message = f"‚ö†Ô∏è Ge√ßersiz anahtar kelime: `{escape_markdown_v2(keyword)}`\\.\nƒ∞zin verilenler: {allowed_str}"
            else:
                # generate_summary i√ßinde escape yapƒ±lƒ±yor
                response_message = generate_summary(keyword)

        elif text.startswith("/analiz"):
            print(">>> /analiz komutu i≈üleniyor...")
            tickers_input = text[8:].strip()
            tickers = [ticker.strip().upper() for ticker in tickers_input.split(",") if ticker.strip()]
            if not tickers:
                # Literal '.' ve parantezler manuel escape
                response_message = "L√ºtfen bir veya daha fazla hisse kodu belirtin\\. √ñrnek: `/analiz AAPL,MSFT,AMD`"
            else:
                # generate_analiz_response i√ßinde escape yapƒ±lƒ±yor
                response_message = generate_analiz_response(tickers)

        elif text.startswith("/bist_analiz"):
            print(">>> /bist_analiz komutu i≈üleniyor...")
            tickers_input = text[13:].strip()
            tickers = [ticker.strip().upper() for ticker in tickers_input.split(",") if ticker.strip()]
            if not tickers:
                 # Literal '.' ve parantezler manuel escape
                response_message = "L√ºtfen bir veya daha fazla hisse kodu belirtin\\. √ñrnek: `/bist_analiz MIATK,THYAO`"
            else:
                # generate_bist_analiz_response i√ßinde escape yapƒ±lƒ±yor (d√ºzeltildi)
                response_message = generate_bist_analiz_response(tickers)

        elif text.startswith("/temizle"):
            print(">>> /temizle komutu i≈üleniyor (Manuel)...")
            clear_signals()
            # Dosya yolunu escape et, literal '.' manuel escape
            response_message = f"‚úÖ `{escape_markdown_v2(SIGNALS_FILE)}` dosyasƒ± manuel olarak temizlendi\\."

        # ... (Diƒüer komutlar veya bilinmeyen komut durumu) ...

        if response_message:
            send_telegram_message(response_message) # Direkt g√∂nder
        else:
             print("ƒ∞≈ülenecek komut bulunamadƒ± veya yanƒ±t olu≈üturulmadƒ±.")

    # ... (Hata yakalama aynƒ±, i√ßindeki escape'ler doƒüru) ...
    except Exception as e:
        print(f"‚ùå /telegram endpoint komut i≈üleme hatasƒ±: {e}"); print(f"‚ùå Hata Tipi: {type(e)}")
        try: error_text = f"Komut i≈ülenirken bir hata olu≈ütu: `{escape_markdown_v2(str(e))}`"; send_telegram_message(f"‚öôÔ∏è *HATA* ‚öôÔ∏è\n{error_text}")
        except Exception as telegram_err: print(f"‚ùå Hata mesajƒ± Telegram'a g√∂nderilemedi: {telegram_err}")

    return "ok", 200


@app.route("/clear_signals", methods=["POST"])
def clear_signals_endpoint():
    print(f"[{datetime.now()}] >>> /clear_signals endpoint tetiklendi (HTTP POST)")
    try:
        clear_signals()
        # Dosya yolunu escape et, literal '.' ve parantezler manuel escape
        send_telegram_message(f"üìÅ `{escape_markdown_v2(SIGNALS_FILE)}` dosyasƒ± HTTP isteƒüi ile temizlendi\\.")
        return f"{SIGNALS_FILE} dosyasƒ± temizlendi!", 200
    except Exception as e:
        print(f"‚ùå Manuel sinyal temizleme hatasƒ± (HTTP): {e}")
        # Dosya yolu, hata mesajƒ± escape ediliyor, literal '.' ve parantezler manuel escape
        send_telegram_message(f"‚ùå `{escape_markdown_v2(SIGNALS_FILE)}` temizlenirken hata olu≈ütu \\(HTTP\\): `{escape_markdown_v2(str(e))}`")
        return str(e), 500

# --- Analiz ve √ñzet Fonksiyonlarƒ± ---

def generate_analiz_response(tickers):
    """analiz.json dosyasƒ±ndan veri √ßekerek basit analiz yanƒ±tƒ± olu≈üturur."""
    analiz_verileri = load_json_file(ANALIZ_FILE)
    analiz_listesi = []
    if not analiz_verileri:
         # Dosya yolunu escape et, literal parantezler ve '.' manuel escape
         return f"‚ö†Ô∏è Analiz verileri \\(`{escape_markdown_v2(ANALIZ_FILE)}`\\) y√ºklenemedi veya bo≈ü\\."

    for ticker in tickers:
        ticker_upper = ticker.strip().upper()
        analiz = analiz_verileri.get(ticker_upper)
        ticker_esc = escape_markdown_v2(ticker_upper) # Ticker'ƒ± escape et
        if analiz:
            puan_raw = analiz.get("puan", 0)
            detaylar_list = analiz.get("detaylar", [])
            # Detaylarƒ± escape et
            detaylar_str = "\n".join([f"\\- {escape_markdown_v2(d)}" for d in detaylar_list]) if detaylar_list else "_Detay bulunamadƒ±_"
            # Yorumu escape et
            yorum = escape_markdown_v2(analiz.get("yorum", "_Yorum bulunamadƒ±_"))
            analiz_listesi.append({
                "ticker": ticker_esc, "puan": puan_raw,
                # Puanƒ± ` i√ßinde g√∂sterdiƒüimiz i√ßin escape etmeye gerek yok
                "puan_str": str(puan_raw),
                "detaylar": detaylar_str, "yorum": yorum
            })
        else:
             # Dosya yolunu escape et, literal parantezler ve '.' manuel escape
            analiz_listesi.append({
                "ticker": ticker_esc, "puan": None, "puan_str": "N/A", "detaylar": None,
                "yorum": f"‚ùå `{ticker_esc}` i√ßin analiz bulunamadƒ± \\(`{escape_markdown_v2(ANALIZ_FILE)}`\\)\\."
            })

    analiz_listesi.sort(key=lambda x: (x["puan"] is not None, x["puan"]), reverse=True)
    response_lines = []
    for analiz in analiz_listesi:
        if analiz["puan"] is not None:
            # Literal parantezleri manuel escape et
            response_lines.append(
                f"üìä *{analiz['ticker']}* Analiz \\(Puan: `{analiz['puan_str']}`\\):\n"
                f"_{analiz['detaylar']}_\n\n" # Detaylar zaten ba≈üƒ±nda \- ile escape edilmi≈üti
                f"*{analiz['yorum']}*"
            )
        else:
            response_lines.append(analiz["yorum"]) # Hata mesajƒ± zaten doƒüru formatta
    return "\n\n---\n\n".join(response_lines)


def format_number_in_string(text):
    """ Metin i√ßindeki '12345.0' -> '12345' yapar. """
    return re.sub(r'(\d+)\.0(?!\d)', r'\1', text)

# *** generate_bist_analiz_response: Yorumlar escape EDƒ∞LMƒ∞YOR, literal karakterler manuel escape ***
def generate_bist_analiz_response(tickers):
    """
    analiz_sonuclari.json'dan veri √ßeker, emoji ekler, .0'ƒ± kaldƒ±rƒ±r.
    Yorum metinlerini escape ETMEZ, sadece literal √∂zel karakterleri manuel ka√ßƒ±rƒ±r.
    """
    all_analiz_data = load_json_file(ANALIZ_SONUCLARI_FILE)
    response_lines = []

    if not all_analiz_data:
         # Dosya yolu escape, literal parantez/nokta manuel escape
         return f"‚ö†Ô∏è Detaylƒ± analiz verileri \\(`{escape_markdown_v2(ANALIZ_SONUCLARI_FILE)}`\\) y√ºklenemedi veya bo≈ü\\."

    emoji_map = {
        "PEG oranƒ±": "üß†", "F/K oranƒ±": "üìà", "Net Bor√ß/FAV√ñK": "üè¶",
        "Net d√∂nem karƒ± artƒ±≈üƒ±": "üîπ", "D√∂nen Varlƒ±klar Artƒ±≈üƒ±": "üîÑ",
        "Duran Varlƒ±klar Artƒ±≈üƒ±": "üèóÔ∏è", "Toplam Varlƒ±klar Artƒ±≈üƒ±": "üèõÔ∏è",
        "Finansal Bor√ß Azalƒ±≈üƒ±": "üìâ", "Net Bor√ß Azalƒ±≈üƒ±": "‚úÖ",
        "√ñzkaynak Artƒ±≈üƒ±": "üí™"
    }
    default_emoji = "üîπ"

    # Hangi karakterlerin yorum i√ßinde manuel escape edilmesi gerektiƒüini tanƒ±mla
    # Bunlar: ( ) < > . - = % + ! # _ * ` [ ] ~
    # Not: _ ve * yorum i√ßinde italik/bold istenmiyorsa escape edilmeli.
    # ` code istenmiyorsa escape edilmeli.
    # [ ] link istenmiyorsa escape edilmeli.
    # ≈ûimdilik sadece parantez, nokta, tire, e≈üittir, y√ºzde, artƒ±, √ºnlem, diyez'i escape edelim.
    # Diƒüerleri ( _ * ` [ ] ~ ) yorumlarda kullanƒ±lmƒ±yor gibi g√∂r√ºn√ºyor.
    chars_to_escape_in_comment = r"()<>.-=%+!#"
    def escape_comment_literals(comment_text):
        return re.sub(r"([{}])".format(re.escape(chars_to_escape_in_comment)), r"\\\1", comment_text)

    for ticker in tickers:
        ticker_upper = ticker.strip().upper()
        analiz_data = all_analiz_data.get(ticker_upper)
        ticker_esc = escape_markdown_v2(ticker_upper) # Sembol her zaman escape edilmeli

        if analiz_data:
            score_raw = analiz_data.get("score", "N/A")
            display_score = str(score_raw) # Escape etme, ` i√ßinde
            try:
                score_float = float(score_raw); display_score = str(int(score_float)) if score_float.is_integer() else str(score_float)
            except (ValueError, TypeError): pass

            classification_raw = analiz_data.get("classification", "Belirtilmemi≈ü")
            classification_esc = escape_markdown_v2(classification_raw) # Sƒ±nƒ±flandƒ±rma metnini escape et
            classification_emoji = "üèÜ"
            comments_raw = analiz_data.get("comments", [])

            # Yorumlarƒ± formatla (emoji + sayƒ± formatlama + Lƒ∞TERAL KA√áIRMA)
            formatted_comments_list = []
            if comments_raw:
                for comment in comments_raw:
                    if not comment: continue
                    prefix_emoji = default_emoji
                    for key, emoji in emoji_map.items():
                        if comment.strip().startswith(key): prefix_emoji = emoji; break

                    formatted_num_comment = format_number_in_string(comment)
                    # Yorum i√ßindeki literal ( ) . - = % + ! # karakterlerini ka√ßƒ±r
                    final_comment_text = escape_comment_literals(formatted_num_comment)
                    formatted_comments_list.append(f"{prefix_emoji} {final_comment_text}")

                formatted_comments = "\n".join(formatted_comments_list)
            else:
                formatted_comments = "_Yorum bulunamadƒ±_" # ƒ∞talik i√ßin _ korunmalƒ±

            # Mesajƒ± olu≈ütur
            response_lines.append(
                f"üìä *{ticker_esc}* Detaylƒ± Analiz:\n\n"
                f"üìà *Puan:* `{display_score}`\n"
                f"{classification_emoji} *Sƒ±nƒ±flandƒ±rma:* {classification_esc}\n\n"
                f"üìù *√ñne √áƒ±kanlar:*\n{formatted_comments}" # Yorumlar artƒ±k manuel escape edilmi≈ü
            )
        else:
             # Hata mesajƒ± zaten doƒüru formatta (√∂nceki adƒ±mdan)
            response_lines.append(f"‚ùå `{ticker_esc}` i√ßin detaylƒ± analiz bulunamadƒ± \\(`{escape_markdown_v2(ANALIZ_SONUCLARI_FILE)}`\\)\\.")

    return "\n\n---\n\n".join(response_lines)


def generate_summary(keyword=None):
    """signals.json dosyasƒ±nƒ± okuyarak sinyal √∂zeti olu≈üturur."""
    if not os.path.exists(SIGNALS_FILE): return "üìä Hen√ºz hi√ß sinyal kaydedilmedi\\."
    lines = []
    try:
        with open(SIGNALS_FILE, "r", encoding="utf-8") as f: lines = f.readlines()
    except IOError as e:
        # Hata mesajƒ±nƒ±/yolunu escape et, literal parantez/nokta manuel escape
        return f"‚ö†Ô∏è Sinyal dosyasƒ± \\(`{escape_markdown_v2(SIGNALS_FILE)}`\\) okunurken bir hata olu≈ütu: `{escape_markdown_v2(str(e))}`"
    if not lines: return "üìä Sinyal dosyasƒ±nda kayƒ±tlƒ± veri bulunamadƒ±\\."

    summary = {
        "g√º√ßl√º": set(), "kairi_-30": set(), "kairi_-20": set(),
        "matisay_-25": set(), "m√ºkemmel_alƒ±≈ü": set(), "alƒ±≈ü_sayƒ±mƒ±": set(),
        "m√ºkemmel_satƒ±≈ü": set(), "satƒ±≈ü_sayƒ±mƒ±": set(),
    }
    parsed_signals = [parse_signal_line(line) for line in lines if line.strip()]
    parsed_signals = [s for s in parsed_signals if s]

    keyword_map = {"bist": "bist_dly", "nasdaq": "bats", "binance": "binance"}
    active_filter = None
    if keyword:
        keyword_lower = keyword.lower()
        active_filter = keyword_map.get(keyword_lower, keyword_lower)
        filtered_signals = [s for s in parsed_signals if active_filter in s.get("exchange", "").lower()]
        if not filtered_signals:
             # keyword escape, literal nokta manuel escape
             return f"üìä `{escape_markdown_v2(keyword)}` filtresi i√ßin sinyal bulunamadƒ±\\."
        parsed_signals = filtered_signals

    processed_symbols_for_strong = set()

    for signal_data in parsed_signals:
        symbol = signal_data.get("symbol", "Bilinmiyor")
        exchange = signal_data.get("exchange", "Bilinmiyor")
        signal_text = signal_data.get("signal", "")
        exchange_display = exchange.replace("BIST_DLY", "BIST").replace("BATS", "NASDAQ")
        base_key = f"{symbol} ({exchange_display})" # Escape edilmemi≈ü anahtar (set i√ßin)
        # G√∂r√ºnt√ºlenecek anahtar: sembol ve borsa escape, parantezler manuel escape
        display_key = f"{escape_markdown_v2(symbol)} \\({escape_markdown_v2(exchange_display)}\\)"
        signal_lower = signal_text.lower()

        def format_value(val_type, val):
            # Deƒüer ` i√ßinde olduƒüu i√ßin sadece val_type escape edilmeli (gerekirse)
            # Ama KAIRI ve Matisay sabit, escape gerektirmez. `-` i≈üareti ` i√ßinde korunur.
            return f"{val_type} `{val}`"

        # KAIRI / Matisay i≈ülemleri...
        try: # Hata yakalamayƒ± geni≈ület
            if "kairi" in signal_lower:
                kairi_match = re.search(r"kairi\s*([-+]?\d*\.?\d+)", signal_lower)
                if kairi_match:
                    kairi_value = round(float(kairi_match.group(1)), 2)
                    kairi_str = format_value("KAIRI", kairi_value)
                    kairi_entry = f"{display_key}: {kairi_str}" # display_key kullan
                    if kairi_value <= -30: summary["kairi_-30"].add(kairi_entry)
                    elif kairi_value <= -20: summary["kairi_-20"].add(kairi_entry)
                    if base_key not in processed_symbols_for_strong:
                        for other in parsed_signals:
                            if other.get("symbol") == symbol and other.get("exchange") == exchange and re.search(r"(m√ºkemmel alƒ±≈ü|alƒ±≈ü sayƒ±mƒ±)", other.get("signal", "").lower()):
                                # Literal '&' ve '-' manuel escape
                                strong_entry = f"‚úÖ {display_key} \\- {kairi_str} \\& Alƒ±≈ü Sinyali"
                                summary["g√º√ßl√º"].add(strong_entry); processed_symbols_for_strong.add(base_key); break
            elif "matisay" in signal_lower:
                matisay_match = re.search(r"matisay\s*([-+]?\d*\.?\d+)", signal_lower)
                if matisay_match:
                    matisay_value = round(float(matisay_match.group(1)), 2)
                    if matisay_value < -25:
                        matisay_str = format_value("Matisay", matisay_value)
                        matisay_entry = f"{display_key}: {matisay_str}" # display_key kullan
                        summary["matisay_-25"].add(matisay_entry)
            elif re.search(r"m√ºkemmel alƒ±≈ü", signal_lower):
                 summary["m√ºkemmel_alƒ±≈ü"].add(display_key) # display_key kullan
                 if base_key not in processed_symbols_for_strong:
                     for other in parsed_signals:
                         if other.get("symbol") == symbol and other.get("exchange") == exchange and "kairi" in other.get("signal", "").lower():
                             kairi_match_rev = re.search(r"kairi\s*([-+]?\d*\.?\d+)", other.get("signal", "").lower())
                             if kairi_match_rev:
                                kairi_val_rev = round(float(kairi_match_rev.group(1)), 2)
                                if kairi_val_rev <= -20:
                                    kairi_rev_str = format_value("KAIRI", kairi_val_rev)
                                    # Literal '&' ve '-' manuel escape
                                    strong_entry = f"‚úÖ {display_key} \\- Alƒ±≈ü Sinyali \\& {kairi_rev_str}"
                                    summary["g√º√ßl√º"].add(strong_entry); processed_symbols_for_strong.add(base_key); break
            elif re.search(r"alƒ±≈ü sayƒ±mƒ±", signal_lower):
                summary["alƒ±≈ü_sayƒ±mƒ±"].add(display_key) # display_key kullan
                if base_key not in processed_symbols_for_strong:
                     for other in parsed_signals:
                         if other.get("symbol") == symbol and other.get("exchange") == exchange and "kairi" in other.get("signal", "").lower():
                             kairi_match_rev = re.search(r"kairi\s*([-+]?\d*\.?\d+)", other.get("signal", "").lower())
                             if kairi_match_rev:
                                kairi_val_rev = round(float(kairi_match_rev.group(1)), 2)
                                if kairi_val_rev <= -20:
                                    kairi_rev_str = format_value("KAIRI", kairi_val_rev)
                                    # Literal '&' ve '-' manuel escape
                                    strong_entry = f"‚úÖ {display_key} \\- Alƒ±≈ü Sayƒ±mƒ± \\& {kairi_rev_str}"
                                    summary["g√º√ßl√º"].add(strong_entry); processed_symbols_for_strong.add(base_key); break
            elif re.search(r"m√ºkemmel satƒ±≈ü", signal_lower): summary["m√ºkemmel_satƒ±≈ü"].add(display_key) # display_key kullan
            elif re.search(r"satƒ±≈ü sayƒ±mƒ±", signal_lower): summary["satƒ±≈ü_sayƒ±mƒ±"].add(display_key) # display_key kullan
        except (ValueError, TypeError) as parse_err:
            print(f"Sinyal √∂zeti parse hatasƒ± ({base_key}): {parse_err} - Sinyal: {signal_text[:50]}...")
        except Exception as e:
            print(f"Sinyal √∂zeti genel hata ({base_key}): {e}")


    # √ñzeti olu≈ütur (Manuel escaping ile)
    msg_parts = []
    # keyword escape, literal parantez/nokta manuel escape
    filter_title = f" \\(`{escape_markdown_v2(keyword)}` Filtresi\\)" if keyword else ""
    msg_parts.append(f"üìä *Sinyal √ñzeti*{filter_title}")

    # Ba≈ülƒ±klardaki √∂zel karakterleri manuel escape et
    category_map = {
        "g√º√ßl√º": "‚úÖ *G√ú√áL√ú E≈ûLE≈ûENLER \\(Alƒ±≈ü \\& KAIRI ‚â§ \\-20\\)*",
        "kairi_-30": "üî¥ *KAIRI ‚â§ \\-30*",
        "kairi_-20": "üü† *\\-30 < KAIRI ‚â§ \\-20*",
        "matisay_-25": "üü£ *Matisay < \\-25*",
        "m√ºkemmel_alƒ±≈ü": "üü¢ *M√ºkemmel Alƒ±≈ü*",
        "alƒ±≈ü_sayƒ±mƒ±": "üìà *Alƒ±≈ü Sayƒ±mƒ± Tamamlananlar*",
        "m√ºkemmel_satƒ±≈ü": "üîµ *M√ºkemmel Satƒ±≈ü*",
        "satƒ±≈ü_sayƒ±mƒ±": "üìâ *Satƒ±≈ü Sayƒ±mƒ± Tamamlananlar*"
    }
    has_content = False
    for key, title in category_map.items():
        if summary[key]:
            has_content = True
            # Liste elemanlarƒ± zaten display_key ile escape edildi. Ba≈ütaki '-' escape edilmeli.
            sorted_items = sorted(list(summary[key]))
            msg_parts.append(f"{title}:\n" + "\n".join(f"\\- {item}" for item in sorted_items))

    if not has_content:
        filter_text = f" `{escape_markdown_v2(keyword)}` filtresi ile" if keyword else ""
        # literal nokta manuel escape
        return f"üìä G√∂sterilecek uygun sinyal bulunamadƒ±{filter_text}\\."

    final_summary = "\n\n".join(msg_parts)
    #print("Olu≈üturulan √ñzet Ba≈ülangƒ±cƒ±:", final_summary[:300] + "...") # Loglama i√ßin ge√ßici kapat
    return final_summary


# --- Arka Plan G√∂revleri ---

def clear_signals():
    try:
        if os.path.exists(SIGNALS_FILE):
            with open(SIGNALS_FILE, "w", encoding="utf-8") as f: f.write("")
            print(f"‚úÖ {SIGNALS_FILE} dosyasƒ± ba≈üarƒ±yla temizlendi!")
        else: print(f"‚ÑπÔ∏è {SIGNALS_FILE} dosyasƒ± bulunamadƒ±, temizleme i≈ülemi atlandƒ±.")
    except IOError as e:
        print(f"‚ùå {SIGNALS_FILE} dosyasƒ± temizlenirken G/√á hatasƒ±: {e}")
        # Hata mesajƒ±/yol escape, literal parantez/nokta manuel escape
        send_telegram_message(f"‚ö†Ô∏è *Otomatik Temizlik Hatasƒ±:* `{escape_markdown_v2(SIGNALS_FILE)}` temizlenemedi \\- G/√á Hatasƒ±: `{escape_markdown_v2(str(e))}`")
    except Exception as e:
        print(f"‚ùå {SIGNALS_FILE} dosyasƒ± temizlenirken beklenmedik hata: {e}")
        # Hata mesajƒ±/yol escape, literal parantez/nokta manuel escape
        send_telegram_message(f"‚ö†Ô∏è *Otomatik Temizlik Hatasƒ± \\(Genel\\):* `{escape_markdown_v2(SIGNALS_FILE)}` temizlenemedi \\- Hata: `{escape_markdown_v2(str(e))}`")

def clear_signals_daily():
    print("üïí G√ºnl√ºk sinyal temizleme g√∂revi ba≈ülatƒ±lƒ±yor...")
    already_cleared_today = False; target_hour, target_minute = 23, 59; check_interval_seconds = 30
    while True:
        try:
            tz_istanbul = pytz.timezone("Europe/Istanbul"); now = datetime.now(tz_istanbul)
            if now.hour == target_hour and now.minute == target_minute:
                if not already_cleared_today:
                    print(f"‚è∞ Zamanƒ± geldi ({now.strftime('%Y-%m-%d %H:%M:%S %Z')}), {SIGNALS_FILE} temizleniyor...")
                    clear_signals()
                    try:
                         # Zaman ve dosya yolu escape, literal parantez/nokta manuel escape
                         timestamp_str = escape_markdown_v2(now.strftime('%Y-%m-%d %H:%M')) # ƒ∞√ßindeki '-' escape edilecek
                         send_telegram_message(f"üßπ G√ºnl√ºk otomatik temizlik yapƒ±ldƒ± \\({timestamp_str}\\)\\. `{escape_markdown_v2(SIGNALS_FILE)}` sƒ±fƒ±rlandƒ±\\.")
                    except Exception as tel_err: print(f"‚ùå Temizlik bildirimi g√∂nderilemedi: {tel_err}")
                    already_cleared_today = True; time.sleep(check_interval_seconds * 2 + 5); continue
            elif already_cleared_today: already_cleared_today = False
            time.sleep(check_interval_seconds)
        except pytz.UnknownTimeZoneError: print("‚ùå Hata: 'Europe/Istanbul' saat dilimi bulunamadƒ±."); time.sleep(check_interval_seconds)
        except Exception as e:
            print(f"‚ùå clear_signals_daily d√∂ng√ºs√ºnde hata: {e}"); print(f"‚ùå Hata Tipi: {type(e)}")
            try:
                 # Hata mesajƒ± escape, literal parantez/nokta manuel escape
                send_telegram_message(f"‚ö†Ô∏è *Kritik Hata:* G√ºnl√ºk temizlik g√∂revinde sorun olu≈ütu\\! Hata: `{escape_markdown_v2(str(e))}`")
            except Exception as tel_err: print(f"‚ùå Kritik hata bildirimi g√∂nderilemedi: {tel_err}")
            time.sleep(60)

# --- Uygulama Ba≈ülatma ---
if __name__ == "__main__":
    if not BOT_TOKEN or not CHAT_ID: print("‚ùå HATA: BOT_TOKEN veya CHAT_ID ayarlanmamƒ±≈ü!"); exit(1)
    print("-" * 30); print("üöÄ Flask Uygulamasƒ± Ba≈ülatƒ±lƒ±yor..."); #... (Diƒüer printler aynƒ±) ...
    print(f"üîß Bot Token: ...{BOT_TOKEN[-6:]}")
    print(f"üîß Chat ID: {CHAT_ID}")
    print(f"üîß Sinyal Dosyasƒ±: {SIGNALS_FILE}")
    print(f"üîß Analiz Dosyasƒ± (Basit): {ANALIZ_FILE}")
    print(f"üîß Analiz Dosyasƒ± (Detaylƒ±): {ANALIZ_SONUCLARI_FILE}")
    print("-" * 30)
    daily_clear_thread = threading.Thread(target=clear_signals_daily, daemon=True); daily_clear_thread.start()
    try: app.run(host="0.0.0.0", port=5000, debug=False)
    except Exception as run_err: print(f"‚ùå Flask uygulamasƒ± ba≈ülatƒ±lƒ±rken hata: {run_err}")
